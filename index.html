<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weekly Song Selector (Cloud-Enabled)</title>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Firebase Compatibility SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth-compat.js"></script>
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        /* Embedded Tailwind CSS (minified) */
        @charset "utf-8";*,:after,:before{box-sizing:border-box;border:0 solid #e5e7eb}html{line-height:1.5;-webkit-text-size-adjust:100%}body{margin:0;font-family:Inter,sans-serif}.container{max-width:1280px;margin:0 auto;padding:1rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.font-bold{font-weight:700}.text-gray-800{--tw-text-opacity:1;color:rgb(31 41 55 / var(--tw-text-opacity))}.mb-6{margin-bottom:1.5rem}.section-full-width{width:100%}.text-center{text-align:center}.user-id-display{font-size:.875rem;color:#6b7280;padding:.5rem}.tab-nav{display:flex;justify-content:center;gap:1rem;margin-bottom:1rem}.tab-button{padding:.5rem 1rem;border:1px solid #d1d5db;border-radius:.375rem;background-color:#f9fafb;cursor:pointer}.tab-button.active{background-color:#4f46e5;color:#fff;border-color:#4f46e5}.section{display:none}.section.active{display:block}.sub-section{margin-bottom:2rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-semibold{font-weight:600}.text-gray-700{--tw-text-opacity:1;color:rgb(55 65 81 / var(--tw-text-opacity))}.mb-4{margin-bottom:1rem}.block{display:block}.text-gray-600{--tw-text-opacity:1;color:rgb(75 85 99 / var(--tw-text-opacity))}.text-sm{font-size:.875rem;line-height:1.25rem}.font-medium{font-weight:500}.mb-2{margin-bottom:.5rem}input,textarea,select{width:100%;padding:.5rem;border:1px solid #d1d5db;border-radius:.375rem}.focus\:ring-indigo-500:focus{--tw-ring-color:#6366f1;outline:2px solid transparent;outline-offset:2px;box-shadow:0 0 0 3px rgba(99,102,241,.5)}.focus\:border-indigo-500:focus{--tw-border-opacity:1;border-color:rgb(99 102 241 / var(--tw-border-opacity))}.text-xs{font-size:.75rem;line-height:1rem}.text-gray-500{--tw-text-opacity:1;color:rgb(107 114 128 / var(--tw-text-opacity))}.mt-1{margin-top:.25rem}.hidden{display:none}.song-row{display:flex;gap:1rem;margin-bottom:1rem}.flex-grow{flex-grow:1}.type-display{font-size:.875rem;color:#6b7280}.highlight-repeat{border-color:#ef4444}.message-box{padding:1rem;border:1px solid transparent;border-radius:.375rem;margin-bottom:1rem;opacity:0;visibility:hidden;transition:opacity .3s ease}.message-box.show{opacity:1;visibility:visible}.bg-blue-100{--tw-bg-opacity:1;background-color:rgb(219 234 254 / var(--tw-bg-opacity))}.border-blue-500{--tw-border-opacity:1;border-color:rgb(59 130 246 / var(--tw-border-opacity))}.text-blue-800{--tw-text-opacity:1;color:rgb(30 64 175 / var(--tw-text-opacity))}.bg-green-100{--tw-bg-opacity:1;background-color:rgb(220 252 231 / var(--tw-bg-opacity))}.border-green-500{--tw-border-opacity:1;border-color:rgb(34 197 94 / var(--tw-border-opacity))}.text-green-800{--tw-text-opacity:1;color:rgb(22 101 52 / var(--tw-text-opacity))}.bg-yellow-100{--tw-bg-opacity:1;background-color:rgb(254 249 195 / var(--tw-bg-opacity))}.border-yellow-500{--tw-border-opacity:1;border-color:rgb(234 179 8 / var(--tw-border-opacity))}.text-yellow-800{--tw-text-opacity:1;color:rgb(133 77 14 / var(--tw-text-opacity))}.bg-red-100{--tw-bg-opacity:1;background-color:rgb(254 226 226 / var(--tw-bg-opacity))}.border-red-500{--tw-border-opacity:1;border-color:rgb(239 68 68 / var(--tw-border-opacity))}.text-red-800{--tw-text-opacity:1;color:rgb(153 27 27 / var(--tw-text-opacity))}.button-group{display:flex;gap:1rem;justify-content:center}.primary,.secondary{padding:.5rem 1rem;border-radius:.375rem;cursor:pointer}.primary{background-color:#4f46e5;color:#fff;border:1px solid #4f46e5}.secondary{background-color:#f9fafb;border:1px solid #d1d5db;color:#374151}.justify-end{justify-content:flex-end}.history-table-container{overflow-x:auto}.history-table{width:100%;border-collapse:collapse}.history-table th,.history-table td{padding:.75rem;border:1px solid #d1d5db;text-align:left}.history-table th{background-color:#f9fafb;font-weight:600}.library-actions-cell{width:100px}.edit-btn,.delete-btn{padding:.25rem .5rem;border-radius:.25rem;font-size:.875rem}.edit-btn{background-color:#4f46e5;color:#fff;border:1px solid #4f46e5}.delete-btn{background-color:#ef4444;color:#fff;border:1px solid #ef4444}.form-group{margin-bottom:1rem}.form-group label{display:block;margin-bottom:.5rem}.w-full{width:100%}.modal{display:none}.modal.show{display:flex;justify-content:center;align-items:center;position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5)}.modal-content{background-color:#fff;padding:1.5rem;border-radius:.5rem;width:100%;max-width:500px}.last-pick-display{padding:1rem;border:1px solid #d1d5db;border-radius:.375rem}.last-pick-display ul{list-style-type:disc;padding-left:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.settings-slot-group{margin-bottom:1rem}.settings-slot-group label{display:block;margin-bottom:.5rem}.hint{font-size:.75rem;color:#6b7280}.loading-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);color:#fff;display:flex;justify-content:center;align-items:center;font-size:1.25rem;display:none}.loading-overlay:not(.hidden){display:flex}
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 section-full-width text-center">Weekly Song Selector</h1>
        <div id="userIdDisplay" class="user-id-display">User: Loading...</div>
        <div class="tab-nav">
            <button class="tab-button active" data-tab="picks">Weekly Picks</button>
            <button class="tab-button" data-tab="library">Manage Library</button>
            <button class="tab-button" data-tab="history">History</button>
            <button class="tab-button" data-tab="settings">Settings</button>
        </div>
        <div id="picks-tab" class="section active">
            <div class="sub-section">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Current Week's Picks</h2>
                <div class="mb-4">
                    <label for="weekStartDate" class="block text-gray-600 text-sm font-medium mb-2">Week Start Date:</label>
                    <input type="date" id="weekStartDate" class="focus:ring-indigo-500 focus:border-indigo-500">
                    <p id="lastPickInfo" class="text-xs text-gray-500 mt-1 hidden"></p>
                </div>
                <div id="songSelectionArea"></div>
                <div id="messageBox" class="message-box"></div>
                <div class="button-group">
                    <button id="savePicksBtn" class="primary">Save Weekly Picks</button>
                    <button id="clearPicksBtn" class="secondary">Clear Current Picks</button>
                </div>
            </div>
            <div class="sub-section">
                <div id="lastSavedPickDisplay" class="last-pick-display hidden">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">Last Saved Weekly Pick (<span id="lastSavedPickDate"></span>)</h3>
                    <ul id="lastSavedPickList"></ul>
                </div>
            </div>
        </div>
        <div id="library-tab" class="section">
            <div class="sub-section section-full-width">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Your Song Library</h2>
                <div class="history-table-container">
                    <table class="history-table">
                        <thead>
                            <tr>
                                <th>Title</th>
                                <th>Artist</th>
                                <th>Groups</th>
                                <th class="library-actions-cell">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="songLibraryTableBody"></tbody>
                    </table>
                </div>
                <div class="button-group justify-end">
                    <button id="downloadLibraryCsvBtn" class="secondary">Download Library CSV</button>
                </div>
            </div>
            <div class="sub-section">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Add New Song</h2>
                <div class="form-group">
                    <label for="newSongTitle">Song Title:</label>
                    <input type="text" id="newSongTitle" placeholder="e.g., My New Jam" class="focus:ring-indigo-500 focus:border-indigo-500 rounded-md">
                </div>
                <div class="form-group">
                    <label for="newSongArtist">Artist:</label>
                    <input type="text" id="newSongArtist" placeholder="e.g., The Awesome Band" class="focus:ring-indigo-500 focus:border-indigo-500 rounded-md">
                </div>
                <div class="form-group">
                    <label for="newSongGroups">Groups (comma-separated):</label>
                    <textarea id="newSongGroups" rows="2" placeholder="e.g., Upbeat, Pop, Dance" class="focus:ring-indigo-500 focus:border-indigo-500 rounded-md"></textarea>
                </div>
                <button id="addSongBtn" class="primary w-full">Add Song to Library</button>
            </div>
            <div class="sub-section">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Upload Songs (CSV)</h2>
                <p class="text-sm text-gray-600 mb-4">Upload a CSV file with columns: `Title`, `Artist`, `Groups`. Groups should be comma-separated in the CSV cell. Existing songs with matching titles will be updated.</p>
                <div class="form-group">
                    <label for="csvFileInput">Select CSV File:</label>
                    <input type="file" id="csvFileInput" accept=".csv" class="focus:ring-indigo-500 focus:border-indigo-500 rounded-md">
                </div>
                <button id="uploadCsvBtn" class="primary w-full">Upload CSV</button>
            </div>
        </div>
        <div id="history-tab" class="section">
            <div class="sub-section section-full-width">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Weekly Picks History</h2>
                <div class="history-table-container">
                    <table class="history-table">
                        <thead>
                            <tr>
                                <th>Week</th>
                                <th>Song 1</th>
                                <th>Song 2</th>
                                <th>Song 3</th>
                                <th>Song 4</th>
                                <th>Song 5</th>
                            </tr>
                        </thead>
                        <tbody id="weeklyPicksHistoryTableBody"></tbody>
                    </table>
                </div>
                <div class="button-group justify-end">
                    <button id="downloadHistoryCsvBtn" class="secondary">Download History CSV</button>
                </div>
            </div>
            <div class="sub-section">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Upload History (CSV)</h2>
                <p class="text-sm text-gray-600 mb-4">Upload a CSV file with columns: `Week` (YYYY-MM-DD), `Song 1`, `Song 2`, etc. Existing weeks will be updated; new weeks will be added.</p>
                <div class="form-group">
                    <label for="historyCsvFileInput">Select History CSV File:</label>
                    <input type="file" id="historyCsvFileInput" accept=".csv" class="focus:ring-indigo-500 focus:border-indigo-500 rounded-md">
                </div>
                <button id="uploadHistoryCsvBtn" class="primary w-full">Upload History CSV</button>
            </div>
        </div>
        <div id="settings-tab" class="section">
            <div class="sub-section section-full-width">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Configure Song Selection Slots</h2>
                <p class="text-sm text-gray-600 mb-6">Define which song groups are allowed in each of the 5 weekly selection dropdowns. Separate multiple groups with commas (e.g., `Worship, Traditional`). Leave a field empty to allow all songs in that slot.</p>
                <div id="slotSettingsArea"></div>
                <div class="button-group">
                    <button id="saveSettingsBtn" class="primary">Save Settings</button>
                </div>
            </div>
        </div>
        <div id="editSongModal" class="modal">
            <div class="modal-content">
                <h3 class="text-xl font-semibold text-gray-700 mb-4">Edit Song Details</h3>
                <input type="hidden" id="editSongUuid">
                <div class="form-group">
                    <label for="editSongTitle">Song Title:</label>
                    <input type="text" id="editSongTitle" class="focus:ring-indigo-500 focus:border-indigo-500 rounded-md">
                </div>
                <div class="form-group">
                    <label for="editSongArtist">Artist:</label>
                    <input type="text" id="editSongArtist" class="focus:ring-indigo-500 focus:border-indigo-500 rounded-md">
                </div>
                <div class="form-group">
                    <label for="editSongGroups">Groups (comma-separated):</label>
                    <textarea id="editSongGroups" rows="2" class="focus:ring-indigo-500 focus:border-indigo-500 rounded-md"></textarea>
                </div>
                <div class="button-group">
                    <button id="deleteSongBtn" class="delete-btn">Delete Song</button>
                    <button id="cancelEditBtn" class="secondary">Cancel</button>
                    <button id="saveEditBtn" class="primary">Save Changes</button>
                </div>
            </div>
        </div>
    </div>
    <div id="loadingOverlay" class="loading-overlay">
        Loading data...
    </div>
    <script>
        // --- DOM Elements (Moved to Top to Avoid Initialization Errors) ---
        const messageBox = document.getElementById('messageBox');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const weekStartDateInput = document.getElementById('weekStartDate');
        const lastPickInfoElement = document.getElementById('lastPickInfo');
        const lastSavedPickDisplay = document.getElementById('lastSavedPickDisplay');
        const lastSavedPickDateElement = document.getElementById('lastSavedPickDate');
        const lastSavedPickListElement = document.getElementById('lastSavedPickList');
        const songSelectionArea = document.getElementById('songSelectionArea');
        const savePicksBtn = document.getElementById('savePicksBtn');
        const clearPicksBtn = document.getElementById('clearPicksBtn');
        const songLibraryTableBody = document.getElementById('songLibraryTableBody');
        const weeklyPicksHistoryTableBody = document.getElementById('weeklyPicksHistoryTableBody');
        const newSongTitleInput = document.getElementById('newSongTitle');
        const newSongArtistInput = document.getElementById('newSongArtist');
        const newSongGroupsInput = document.getElementById('newSongGroups');
        const addSongBtn = document.getElementById('addSongBtn');
        const csvFileInput = document.getElementById('csvFileInput');
        const uploadCsvBtn = document.getElementById('uploadCsvBtn');
        const historyCsvFileInput = document.getElementById('historyCsvFileInput');
        const uploadHistoryCsvBtn = document.getElementById('uploadHistoryCsvBtn');
        const downloadLibraryCsvBtn = document.getElementById('downloadLibraryCsvBtn');
        const downloadHistoryCsvBtn = document.getElementById('downloadHistoryCsvBtn');
        const editSongModal = document.getElementById('editSongModal');
        const editSongUuidInput = document.getElementById('editSongUuid');
        const editSongTitleInput = document.getElementById('editSongTitle');
        const editSongArtistInput = document.getElementById('editSongArtist');
        const editSongGroupsInput = document.getElementById('editSongGroups');
        const saveEditBtn = document.getElementById('saveEditBtn');
        const cancelEditBtn = document.getElementById('cancelEditBtn');
        const deleteSongBtn = document.getElementById('deleteSongBtn');
        const slotSettingsArea = document.getElementById('slotSettingsArea');
        const saveSettingsBtn = document.getElementById('saveSettingsBtn');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const tabButtons = document.querySelectorAll('.tab-button');
        const sections = document.querySelectorAll('.section');

        // --- Initialize Firebase ---
        try {
            const firebaseConfig = {
  apiKey: "AIzaSyCtSsiOgrPB_-hcjxKaaT4j0TUSK9_FPi8",
  authDomain: "song-selector-1.firebaseapp.com",
  projectId: "song-selector-1",
  storageBucket: "song-selector-1.firebasestorage.app",
  messagingSenderId: "403585595499",
  appId: "1:403585595499:web:3bac104aadafb0b6b2d92e"
            };
            firebase.initializeApp(firebaseConfig);
            const db = firebase.firestore();
            const auth = firebase.auth();
            console.log("Firebase initialized successfully");
        } catch (error) {
            console.error("Firebase initialization error:", error);
            showMessage("Failed to connect to database. Loading default data.", "error");
            initializeAppWithDefaults();
        }

        // --- Global Variables ---
        let isAppInitialized = false;
        let currentUser = null;
        let songLibrary = [];
        let weeklyPicksHistory = [];
        let allowedGroupsForSlots = [];

        const NUM_SONG_PICKS = 5;
        const MONTH_IN_MS = 30 * 24 * 60 * 60 * 1000;

        // Default data
        const defaultSongLibrary = [
            { title: "Amazing Grace", artist: "John Newton", groups: ["Worship", "Traditional", "Hymn"] },
            { title: "Happy Tune", artist: "Indie Band", groups: ["Upbeat", "New Release"] },
            { title: "Quiet Reflection", artist: "Solo Piano", groups: ["Chill", "Acoustic", "Instrumental"] },
            { title: "Joyful Noise", artist: "Gospel Choir", groups: ["Worship", "Upbeat"] },
            { title: "Old Gold", artist: "Classic Rock", groups: ["Upbeat", "Old School"] }
        ];
        const defaultAllowedGroupsForSlots = [
            ["Worship"],
            ["Upbeat", "Dance"],
            ["Chill", "Instrumental"],
            [],
            []
        ];

        // --- Utility Functions ---
        function showMessage(message, type = "info") {
            if (!messageBox) {
                console.error("messageBox element not found");
                return;
            }
            messageBox.textContent = message;
            messageBox.className = 'message-box show';
            messageBox.classList.remove('bg-green-100', 'border-green-500', 'text-green-800',
                                       'bg-yellow-100', 'border-yellow-500', 'text-yellow-800',
                                       'bg-red-100', 'border-red-500', 'text-red-800',
                                       'bg-blue-100', 'border-blue-500', 'text-blue-800');
            if (type === "success") {
                messageBox.classList.add('bg-green-100', 'border-green-500', 'text-green-800');
            } else if (type === "warning") {
                messageBox.classList.add('bg-yellow-100', 'border-yellow-500', 'text-yellow-800');
            } else if (type === "error") {
                messageBox.classList.add('bg-red-100', 'border-red-500', 'text-red-800');
            } else {
                messageBox.classList.add('bg-blue-100', 'border-blue-500', 'text-blue-800');
            }
            setTimeout(() => messageBox.classList.remove('show'), 5000);
        }

        function formatDate(date) {
            try {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            } catch (error) {
                console.error("Date formatting error:", error);
                return "";
            }
        }

        function showLoading() {
            if (loadingOverlay) loadingOverlay.classList.remove('hidden');
        }

        function hideLoading() {
            if (loadingOverlay) loadingOverlay.classList.add('hidden');
        }

        function escapeCsv(value) {
            if (value === null || value === undefined) return '';
            let stringValue = String(value);
            if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                return `"${stringValue.replace(/"/g, '""')}"`;
            }
            return stringValue;
        }

        function downloadCSV(filename, csvString) {
            try {
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error("CSV download error:", error);
                showMessage("Failed to download CSV.", "error");
            }
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // --- Firestore Operations ---
        async function loadFromFirestore(collection, defaultValue) {
            if (!currentUser) {
                console.warn(`No user authenticated for loading ${collection}`);
                return defaultValue;
            }
            try {
                const docRef = db.collection('users').doc(currentUser.uid).collection(collection).doc('data');
                const doc = await docRef.get();
                return doc.exists ? doc.data().items : defaultValue;
            } catch (error) {
                console.error(`Error loading ${collection} from Firestore:`, error);
                showMessage(`Error loading ${collection}. Using default data.`, "error");
                return defaultValue;
            }
        }

        async function saveToFirestore(collection, data) {
            if (!currentUser) {
                console.warn(`No user authenticated for saving ${collection}`);
                showMessage("Not authenticated. Cannot save data.", "error");
                return;
            }
            try {
                await db.collection('users').doc(currentUser.uid).collection(collection).doc('data').set({ items: data });
                console.log(`Saved ${collection} to Firestore`);
            } catch (error) {
                console.error(`Error saving ${collection} to Firestore:`, error);
                showMessage(`Error saving ${collection}.`, "error");
            }
        }

        // --- Authentication ---
        try {
            auth.onAuthStateChanged(user => {
                if (user) {
                    currentUser = user;
                    userIdDisplay.textContent = `User: ${user.email || 'Anonymous'}`;
                    console.log("User authenticated:", user.uid);
                    initializeApp();
                } else {
                    auth.signInAnonymously().catch(error => {
                        console.error("Authentication error:", error);
                        showMessage(`Authentication error: ${error.message}. Loading default data.`, "error");
                        initializeAppWithDefaults();
                    });
                }
            });
        } catch (error) {
            console.error("Auth state change error:", error);
            showMessage("Failed to initialize authentication. Loading default data.", "error");
            initializeAppWithDefaults();
        }

        // --- Core Application Logic ---
        async function initializeApp() {
            if (isAppInitialized) return;
            isAppInitialized = true;
            showLoading();
            try {
                songLibrary = await loadFromFirestore('songLibrary', defaultSongLibrary.map(song => ({ ...song, uuid: generateUUID() })));
                weeklyPicksHistory = await loadFromFirestore('weeklyPicksHistory', []);
                allowedGroupsForSlots = await loadFromFirestore('allowedGroupsForSlots', defaultAllowedGroupsForSlots);
                console.log("App data loaded:", { songLibrary, weeklyPicksHistory, allowedGroupsForSlots });
                showMessage("Data loaded from cloud storage.", "success");
                renderSongLibrary();
                renderWeeklyPicksHistory();
                initializeCurrentWeekSelection();
                renderLastSavedPick();
                renderSettingsInputs();
                updateAllSongDropdowns();
            } catch (error) {
                console.error("App initialization error:", error);
                showMessage("Failed to initialize app data. Loading default data.", "error");
                initializeAppWithDefaults();
            } finally {
                hideLoading();
            }
        }

        function initializeAppWithDefaults() {
            songLibrary = defaultSongLibrary.map(song => ({ ...song, uuid: generateUUID() }));
            weeklyPicksHistory = [];
            allowedGroupsForSlots = defaultAllowedGroupsForSlots;
            console.log("Initialized with default data:", { songLibrary, weeklyPicksHistory, allowedGroupsForSlots });
            userIdDisplay.textContent = "User: Offline (Default Data)";
            renderSongLibrary();
            renderWeeklyPicksHistory();
            initializeCurrentWeekSelection();
            renderLastSavedPick();
            renderSettingsInputs();
            updateAllSongDropdowns();
            hideLoading();
            showMessage("App loaded with default data (offline mode).", "warning");
        }

        function renderSongLibrary() {
            try {
                songLibraryTableBody.innerHTML = '';
                const sortedSongs = [...songLibrary].sort((a, b) => a.title.localeCompare(b.title));
                if (sortedSongs.length === 0) {
                    songLibraryTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-gray-500 py-4">No songs in library. Add some!</td></tr>`;
                    return;
                }
                sortedSongs.forEach(song => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${escapeCsv(song.title)}</td>
                        <td>${escapeCsv(song.artist)}</td>
                        <td>${escapeCsv(song.groups.join(', '))}</td>
                        <td class="library-actions-cell">
                            <button class="edit-btn" data-uuid="${song.uuid}">Edit</button>
                        </td>
                    `;
                    songLibraryTableBody.appendChild(row);
                });
                document.querySelectorAll('.edit-btn').forEach(button => {
                    button.addEventListener('click', () => openEditModal(button.dataset.uuid));
                });
                console.log("Song library rendered");
            } catch (error) {
                console.error("Error rendering song library:", error);
                showMessage("Failed to display song library.", "error");
            }
        }

        function populateSongDropdown(selectElement, allowedGroups = []) {
            try {
                selectElement.innerHTML = '<option value="">-- Select a Song --</option>';
                let filteredSongs = allowedGroups.length === 0 || allowedGroups.every(g => g === '') ?
                    [...songLibrary] :
                    songLibrary.filter(song => song.groups && song.groups.some(group => allowedGroups.includes(group)));
                const sortedSongs = [...filteredSongs].sort((a, b) => a.title.localeCompare(b.title));
                sortedSongs.forEach(song => {
                    const option = document.createElement('option');
                    option.value = song.uuid;
                    option.textContent = song.title;
                    selectElement.appendChild(option);
                });
            } catch (error) {
                console.error("Error populating song dropdown:", error);
                showMessage("Failed to populate song dropdown.", "error");
            }
        }

        function updateAllSongDropdowns() {
            try {
                for (let i = 0; i < NUM_SONG_PICKS; i++) {
                    const select = document.getElementById(`songSelect${i + 1}`);
                    if (select) {
                        const currentSelectedUuid = select.value;
                        const groupsForThisSlot = (allowedGroupsForSlots[i] && Array.isArray(allowedGroupsForSlots[i])) ? allowedGroupsForSlots[i] : [];
                        populateSongDropdown(select, groupsForThisSlot);
                        select.value = currentSelectedUuid;
                        select.dispatchEvent(new Event('change'));
                    }
                }
                console.log("Song dropdowns updated");
            } catch (error) {
                console.error("Error updating song dropdowns:", error);
                showMessage("Failed to update song dropdowns.", "error");
            }
        }

        function getSongByUUID(uuid) {
            return songLibrary.find(song => song.uuid === uuid);
        }

        function getSongByTitle(title) {
            return songLibrary.find(song => song.title && title && song.title.toLowerCase() === title.toLowerCase());
        }

        function updateSongType(selectElement, typeDisplayElement) {
            try {
                const selectedSongUuid = selectElement.value;
                const song = getSongByUUID(selectedSongUuid);
                typeDisplayElement.textContent = song && song.groups ? song.groups.join(', ') : '';
            } catch (error) {
                console.error("Error updating song type:", error);
                typeDisplayElement.textContent = '';
            }
        }

        function isSongPlayedRecently(songUuid, currentWeekStartDate) {
            try {
                const oneMonthAgo = currentWeekStartDate.getTime() - MONTH_IN_MS;
                return weeklyPicksHistory.some(week => {
                    const pickDate = new Date(week.date);
                    return pickDate.getTime() >= oneMonthAgo && pickDate.getTime() < currentWeekStartDate.getTime() && week.songUuids.includes(songUuid);
                });
            } catch (error) {
                console.error("Error checking recent song play:", error);
                return false;
            }
        }

        function initializeCurrentWeekSelection() {
            try {
                songSelectionArea.innerHTML = '';
                let latestPick = weeklyPicksHistory.length > 0 ?
                    [...weeklyPicksHistory].sort((a, b) => new Date(b.date) - new Date(a.date))[0] : null;
                weekStartDateInput.value = latestPick ? latestPick.date : formatDate(new Date());
                if (latestPick) {
                    lastPickInfoElement.textContent = `Pre-filled from picks saved on: ${formatDate(new Date(latestPick.date))}`;
                    lastPickInfoElement.classList.remove('hidden');
                } else {
                    lastPickInfoElement.classList.add('hidden');
                }
                for (let i = 0; i < NUM_SONG_PICKS; i++) {
                    const songRow = document.createElement('div');
                    songRow.className = 'song-row';
                    const select = document.createElement('select');
                    select.id = `songSelect${i + 1}`;
                    select.className = 'flex-grow';
                    const groupsForThisSlot = allowedGroupsForSlots[i] || [];
                    populateSongDropdown(select, groupsForThisSlot);
                    const typeDisplay = document.createElement('div');
                    typeDisplay.id = `songType${i + 1}`;
                    typeDisplay.className = 'type-display';
                    select.addEventListener('change', () => {
                        updateSongType(select, typeDisplay);
                        checkAllCurrentPicksForRepeats();
                    });
                    songRow.appendChild(select);
                    songRow.appendChild(typeDisplay);
                    songSelectionArea.appendChild(songRow);
                    if (latestPick && latestPick.songUuids[i]) {
                        select.value = latestPick.songUuids[i];
                        updateSongType(select, typeDisplay);
                    }
                }
                checkAllCurrentPicksForRepeats();
                console.log("Current week selection initialized");
            } catch (error) {
                console.error("Error initializing week selection:", error);
                showMessage("Failed to initialize song selection.", "error");
            }
        }

        function checkAllCurrentPicksForRepeats() {
            try {
                if (!weekStartDateInput.value) {
                    showMessage("Please select a valid week start date.", "error");
                    return;
                }
                const currentWeekStartDate = new Date(weekStartDateInput.value);
                if (isNaN(currentWeekStartDate.getTime())) {
                    showMessage("Invalid week start date.", "error");
                    return;
                }
                let hasRepeats = false;
                for (let i = 0; i < NUM_SONG_PICKS; i++) {
                    const select = document.getElementById(`songSelect${i + 1}`);
                    const songUuid = select.value;
                    select.classList.remove('highlight-repeat');
                    if (songUuid && isSongPlayedRecently(songUuid, currentWeekStartDate)) {
                        select.classList.add('highlight-repeat');
                        hasRepeats = true;
                    }
                }
                if (hasRepeats) {
                    showMessage("One or more selected songs have been played in the last month. Highlighted in red.", "warning");
                } else {
                    const currentMessageType = messageBox.classList.contains('bg-red-100') ? 'error' :
                                              messageBox.classList.contains('bg-green-100') ? 'success' : 'info';
                    if (currentMessageType === 'info' || currentMessageType === 'warning') {
                        messageBox.classList.remove('show');
                    }
                }
            } catch (error) {
                console.error("Error checking repeats:", error);
                showMessage("Failed to check song repeats.", "error");
            }
        }

        function renderWeeklyPicksHistory() {
            try {
                weeklyPicksHistoryTableBody.innerHTML = '';
                if (weeklyPicksHistory.length === 0) {
                    weeklyPicksHistoryTableBody.innerHTML = `<tr><td colspan="6" class="text-center text-gray-500 py-4">No history yet. Save your first week's picks!</td></tr>`;
                    return;
                }
                const sortedHistory = [...weeklyPicksHistory].sort((a, b) => new Date(b.date) - new Date(a.date));
                sortedHistory.forEach(week => {
                    const row = document.createElement('tr');
                    const weekDate = new Date(week.date);
                    const songTitles = week.songUuids.map(uuid => {
                        const song = getSongByUUID(uuid);
                        return song ? song.title : "[Song Not Found]";
                    });
                    row.innerHTML = `
                        <td>${formatDate(weekDate)}</td>
                        ${songTitles.map(title => `<td>${escapeCsv(title)}</td>`).join('')}
                    `;
                    weeklyPicksHistoryTableBody.appendChild(row);
                });
                console.log("Weekly picks history rendered");
            } catch (error) {
                console.error("Error rendering history:", error);
                showMessage("Failed to display history.", "error");
            }
        }

        function renderLastSavedPick() {
            try {
                lastSavedPickListElement.innerHTML = '';
                lastSavedPickDisplay.classList.add('hidden');
                if (weeklyPicksHistory.length === 0) return;
                const latestPick = weeklyPicksHistory.sort((a, b) => new Date(b.date) - new Date(a.date))[0];
                if (latestPick) {
                    lastSavedPickDateElement.textContent = formatDate(new Date(latestPick.date));
                    latestPick.songUuids.forEach(uuid => {
                        const song = getSongByUUID(uuid);
                        const listItem = document.createElement('li');
                        listItem.textContent = song ? `${song.title} by ${song.artist || 'Unknown Artist'}` : "[Song Not Found]";
                        lastSavedPickListElement.appendChild(listItem);
                    });
                    lastSavedPickDisplay.classList.remove('hidden');
                }
            } catch (error) {
                console.error("Error rendering last saved pick:", error);
                showMessage("Failed to display last saved pick.", "error");
            }
        }

        function renderSettingsInputs() {
            try {
                slotSettingsArea.innerHTML = '';
                for (let i = 0; i < NUM_SONG_PICKS; i++) {
                    const slotGroupDiv = document.createElement('div');
                    slotGroupDiv.className = 'settings-slot-group';
                    const label = document.createElement('label');
                    label.setAttribute('for', `slotGroups${i + 1}`);
                    label.textContent = `Song ${i + 1} Allowed Groups:`;
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `slotGroups${i + 1}`;
                    input.className = 'rounded-md focus:ring-indigo-500 focus:border-indigo-500';
                    input.placeholder = 'e.g., Worship, Upbeat, Instrumental';
                    input.value = allowedGroupsForSlots[i] && allowedGroupsForSlots[i].length > 0 ? allowedGroupsForSlots[i].join(', ') : '';
                    const hint = document.createElement('p');
                    hint.className = 'hint';
                    hint.textContent = 'Separate multiple groups with commas. Leave empty for all songs.';
                    slotGroupDiv.appendChild(label);
                    slotGroupDiv.appendChild(input);
                    slotGroupDiv.appendChild(hint);
                    slotSettingsArea.appendChild(slotGroupDiv);
                }
                console.log("Settings inputs rendered");
            } catch (error) {
                console.error("Error rendering settings inputs:", error);
                showMessage("Failed to display settings.", "error");
            }
        }

        // --- Tab Management ---
        function showTab(tabId) {
            try {
                sections.forEach(section => section.classList.remove('active'));
                tabButtons.forEach(button => button.classList.remove('active'));
                document.getElementById(`${tabId}-tab`).classList.add('active');
                document.querySelector(`.tab-button[data-tab="${tabId}"]`).classList.add('active');
            } catch (error) {
                console.error("Error switching tabs:", error);
                showMessage("Failed to switch tabs.", "error");
            }
        }

        tabButtons.forEach(button => {
            button.addEventListener('click', () => showTab(button.dataset.tab));
        });

        // --- Event Handlers ---
        savePicksBtn.addEventListener('click', async () => {
            try {
                if (!weekStartDateInput.value) {
                    showMessage("Please select a valid week start date.", "error");
                    return;
                }
                const currentWeekStartDate = new Date(weekStartDateInput.value);
                if (isNaN(currentWeekStartDate.getTime())) {
                    showMessage("Invalid week start date.", "error");
                    return;
                }
                const selectedSongUuids = [];
                let allSongsSelected = true;
                let hasRecentRepeats = false;
                for (let i = 0; i < NUM_SONG_PICKS; i++) {
                    const select = document.getElementById(`songSelect${i + 1}`);
                    const songUuid = select.value;
                    if (!songUuid) {
                        allSongsSelected = false;
                        break;
                    }
                    selectedSongUuids.push(songUuid);
                    if (isSongPlayedRecently(songUuid, currentWeekStartDate)) {
                        select.classList.add('highlight-repeat');
                        hasRecentRepeats = true;
                    } else {
                        select.classList.remove('highlight-repeat');
                    }
                }
                if (!allSongsSelected) {
                    showMessage("Please select 5 songs before saving.", "error");
                    return;
                }
                if (hasRecentRepeats) {
                    const confirmSave = window.confirm("Some selected songs have been played recently. Do you still want to save?");
                    if (!confirmSave) return;
                }
                weeklyPicksHistory = weeklyPicksHistory.filter(week => week.date !== currentWeekStartDate.toISOString().split('T')[0]);
                weeklyPicksHistory.push({ date: currentWeekStartDate.toISOString().split('T')[0], songUuids: selectedSongUuids });
                await saveToFirestore('weeklyPicksHistory', weeklyPicksHistory);
                showMessage("Weekly picks saved successfully!", "success");
                renderWeeklyPicksHistory();
                renderLastSavedPick();
                initializeCurrentWeekSelection();
            } catch (error) {
                console.error("Error saving picks:", error);
                showMessage("Failed to save weekly picks.", "error");
            }
        });

        clearPicksBtn.addEventListener('click', () => {
            try {
                clearCurrentPicks();
                showMessage("Current picks cleared.", "info");
            } catch (error) {
                console.error("Error clearing picks:", error);
                showMessage("Failed to clear picks.", "error");
            }
        });

        function clearCurrentPicks() {
            try {
                for (let i = 0; i < NUM_SONG_PICKS; i++) {
                    const select = document.getElementById(`songSelect${i + 1}`);
                    const typeDisplay = document.getElementById(`songType${i + 1}`);
                    select.value = "";
                    select.classList.remove('highlight-repeat');
                    typeDisplay.textContent = "";
                }
                weekStartDateInput.value = formatDate(new Date());
                lastPickInfoElement.classList.add('hidden');
                messageBox.classList.remove('show');
            } catch (error) {
                console.error("Error clearing current picks:", error);
                showMessage("Failed to clear current picks.", "error");
            }
        }

        weekStartDateInput.addEventListener('change', checkAllCurrentPicksForRepeats);

        addSongBtn.addEventListener('click', async () => {
            try {
                const title = newSongTitleInput.value.trim();
                const artist = newSongArtistInput.value.trim();
                const groupsString = newSongGroupsInput.value.trim();
                if (!title) {
                    showMessage("Song Title cannot be empty.", "error");
                    return;
                }
                const groups = groupsString.split(',').map(g => g.trim()).filter(g => g !== '');
                if (getSongByTitle(title)) {
                    showMessage(`Song "${title}" already exists in the library.`, "warning");
                    return;
                }
                const newSong = { uuid: generateUUID(), title, artist, groups };
                songLibrary.push(newSong);
                await saveToFirestore('songLibrary', songLibrary);
                showMessage(`Song "${title}" added successfully!`, "success");
                newSongTitleInput.value = '';
                newSongArtistInput.value = '';
                newSongGroupsInput.value = '';
                renderSongLibrary();
                updateAllSongDropdowns();
            } catch (error) {
                console.error("Error adding song:", error);
                showMessage("Failed to add song.", "error");
            }
        });

        async function parseSongLibraryCSV(csvText) {
            try {
                const parseResult = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    transform: (value) => value.trim()
                });
                if (parseResult.errors.length > 0) {
                    showMessage("Error parsing CSV file. Please check its format.", "error");
                    return;
                }
                const requiredFields = ['Title', 'Artist', 'Groups'];
                const headers = parseResult.meta.fields;
                if (!requiredFields.every(field => headers.includes(field))) {
                    showMessage("CSV header must contain 'Title', 'Artist', and 'Groups'.", "error");
                    return;
                }
                let addedCount = 0;
                let updatedCount = 0;
                let skippedCount = 0;
                let tempSongLibrary = [...songLibrary];
                for (const row of parseResult.data) {
                    const title = row.Title;
                    const artist = row.Artist || '';
                    const groupsString = row.Groups || '';
                    if (!title) {
                        console.warn(`Skipping row due to missing Title:`, row);
                        skippedCount++;
                        continue;
                    }
                    const groups = groupsString.split(',').map(g => g.trim()).filter(g => g !== '');
                    const existingSongIndex = tempSongLibrary.findIndex(song => song.title.toLowerCase() === title.toLowerCase());
                    if (existingSongIndex !== -1) {
                        tempSongLibrary[existingSongIndex].artist = artist;
                        tempSongLibrary[existingSongIndex].groups = groups;
                        updatedCount++;
                    } else {
                        tempSongLibrary.push({ uuid: generateUUID(), title, artist, groups });
                        addedCount++;
                    }
                }
                songLibrary = tempSongLibrary;
                await saveToFirestore('songLibrary', songLibrary);
                let message = '';
                if (addedCount > 0) message += `${addedCount} song(s) added. `;
                if (updatedCount > 0) message += `${updatedCount} song(s) updated. `;
                if (skippedCount > 0) message += `${skippedCount} song(s) skipped (missing title).`;
                showMessage(message || "No valid songs found in CSV.", message ? "success" : "warning");
                renderSongLibrary();
                updateAllSongDropdowns();
            } catch (error) {
                console.error("Error parsing song library CSV:", error);
                showMessage("Error processing song library CSV.", "error");
            }
        }

        uploadCsvBtn.addEventListener('click', () => {
            try {
                const file = csvFileInput.files[0];
                if (!file) {
                    showMessage("Please select a CSV file to upload.", "error");
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => parseSongLibraryCSV(e.target.result);
                reader.onerror = () => showMessage("Failed to read file.", "error");
                reader.readAsText(file);
                csvFileInput.value = '';
            } catch (error) {
                console.error("Error uploading CSV:", error);
                showMessage("Failed to upload CSV.", "error");
            }
        });

        downloadLibraryCsvBtn.addEventListener('click', () => {
            try {
                if (songLibrary.length === 0) {
                    showMessage("Song library is empty. Nothing to download.", "warning");
                    return;
                }
                let csvContent = "Title,Artist,Groups\n";
                songLibrary.forEach(song => {
                    const row = [escapeCsv(song.title), escapeCsv(song.artist), escapeCsv(song.groups.join(', '))];
                    csvContent += row.join(',') + "\n";
                });
                downloadCSV("song_library.csv", csvContent);
                showMessage("Song library downloaded as CSV.", "success");
            } catch (error) {
                console.error("Error downloading library CSV:", error);
                showMessage("Failed to download song library.", "error");
            }
        });

        async function parseHistoryCSV(csvText) {
            try {
                const parseResult = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    transform: (value) => value.trim()
                });
                if (parseResult.errors.length > 0) {
                    showMessage("Error parsing history CSV file. Please check its format.", "error");
                    return;
                }
                const headers = parseResult.meta.fields;
                const weekIndex = headers.indexOf('Week');
                const songTitleIndices = [];
                for (let i = 1; i <= NUM_SONG_PICKS; i++) {
                    const songIndex = headers.indexOf(`Song ${i}`);
                    if (songIndex !== -1) songTitleIndices.push(songIndex);
                }
                if (weekIndex === -1 || songTitleIndices.length === 0) {
                    showMessage("History CSV header must contain 'Week' and at least one 'Song X' column.", "error");
                    return;
                }
                let addedWeeks = 0;
                let updatedWeeks = 0;
                let skippedWeeks = 0;
                let tempHistory = [...weeklyPicksHistory];
                for (const row of parseResult.data) {
                    const weekDate = row.Week;
                    if (!weekDate || !/^\d{4}-\d{2}-\d{2}$/.test(weekDate)) {
                        console.warn(`Skipping row due to invalid Week date format:`, row);
                        skippedWeeks++;
                        continue;
                    }
                    const songUuidsForWeek = [];
                    let hasMissingSongs = false;
                    for (let i = 1; i <= NUM_SONG_PICKS; i++) {
                        const songTitle = row[`Song ${i}`] || '';
                        if (songTitle) {
                            const song = getSongByTitle(songTitle);
                            if (song) {
                                songUuidsForWeek.push(song.uuid);
                            } else {
                                console.warn(`Song "${songTitle}" not found in library for week ${weekDate}.`);
                                songUuidsForWeek.push("[Song Not Found]");
                                hasMissingSongs = true;
                            }
                        } else {
                            songUuidsForWeek.push("");
                        }
                    }
                    const existingWeekIndex = tempHistory.findIndex(week => week.date === weekDate);
                    if (existingWeekIndex !== -1) {
                        tempHistory[existingWeekIndex].songUuids = songUuidsForWeek;
                        updatedWeeks++;
                    } else {
                        tempHistory.push({ date: weekDate, songUuids: songUuidsForWeek });
                        addedWeeks++;
                    }
                    if (hasMissingSongs) {
                        showMessage(`Some songs for week ${weekDate} were not found in your library.`, "warning");
                    }
                }
                weeklyPicksHistory = tempHistory;
                weeklyPicksHistory.sort((a, b) => new Date(b.date) - new Date(a.date));
                await saveToFirestore('weeklyPicksHistory', weeklyPicksHistory);
                let message = '';
                if (addedWeeks > 0) message += `${addedWeeks} week(s) added. `;
                if (updatedWeeks > 0) message += `${updatedWeeks} week(s) updated. `;
                if (skippedWeeks > 0) message += `${skippedWeeks} week(s) skipped (invalid date).`;
                showMessage(message || "No valid history entries found in CSV.", message ? "success" : "warning");
                renderWeeklyPicksHistory();
                renderLastSavedPick();
                initializeCurrentWeekSelection();
            } catch (error) {
                console.error("Error parsing history CSV:", error);
                showMessage("Error processing history CSV.", "error");
            }
        }

        uploadHistoryCsvBtn.addEventListener('click', () => {
            try {
                const file = historyCsvFileInput.files[0];
                if (!file) {
                    showMessage("Please select a History CSV file to upload.", "error");
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => parseHistoryCSV(e.target.result);
                reader.onerror = () => showMessage("Failed to read file.", "error");
                reader.readAsText(file);
                historyCsvFileInput.value = '';
            } catch (error) {
                console.error("Error uploading history CSV:", error);
                showMessage("Failed to upload history CSV.", "error");
            }
        });

        downloadHistoryCsvBtn.addEventListener('click', () => {
            try {
                if (weeklyPicksHistory.length === 0) {
                    showMessage("Weekly picks history is empty. Nothing to download.", "warning");
                    return;
                }
                let csvContent = "Week,Song 1,Song 2,Song 3,Song 4,Song 5\n";
                weeklyPicksHistory.forEach(week => {
                    const songTitles = week.songUuids.map(uuid => {
                        const song = getSongByUUID(uuid);
                        return song ? song.title : "[Song Not Found]";
                    });
                    const row = [escapeCsv(week.date), ...songTitles.map(title => escapeCsv(title))];
                    csvContent += row.join(',') + "\n";
                });
                downloadCSV("weekly_picks_history.csv", csvContent);
                showMessage("Weekly picks history downloaded as CSV.", "success");
            } catch (error) {
                console.error("Error downloading history CSV:", error);
                showMessage("Failed to download history.", "error");
            }
        });

        function openEditModal(uuid) {
            try {
                const songToEdit = getSongByUUID(uuid);
                if (!songToEdit) {
                    showMessage("Song not found for editing.", "error");
                    return;
                }
                editSongUuidInput.value = songToEdit.uuid;
                editSongTitleInput.value = songToEdit.title;
                editSongArtistInput.value = songToEdit.artist || '';
                editSongGroupsInput.value = songToEdit.groups ? songToEdit.groups.join(', ') : '';
                editSongModal.classList.add('show');
            } catch (error) {
                console.error("Error opening edit modal:", error);
                showMessage("Failed to open edit modal.", "error");
            }
        }

        function closeEditModal() {
            try {
                editSongModal.classList.remove('show');
                editSongUuidInput.value = '';
                editSongTitleInput.value = '';
                editSongArtistInput.value = '';
                editSongGroupsInput.value = '';
            } catch (error) {
                console.error("Error closing edit modal:", error);
                showMessage("Failed to close edit modal.", "error");
            }
        }

        saveEditBtn.addEventListener('click', async () => {
            try {
                const uuid = editSongUuidInput.value;
                const newTitle = editSongTitleInput.value.trim();
                const newArtist = editSongArtistInput.value.trim();
                const newGroupsString = editSongGroupsInput.value.trim();
                if (!newTitle) {
                    showMessage("Song Title cannot be empty.", "error");
                    return;
                }
                const newGroups = newGroupsString.split(',').map(g => g.trim()).filter(g => g !== '');
                const songIndex = songLibrary.findIndex(song => song.uuid === uuid);
                if (songIndex === -1) {
                    showMessage("Error: Song not found in library.", "error");
                    closeEditModal();
                    return;
                }
                const existingSongWithSameTitle = getSongByTitle(newTitle);
                if (existingSongWithSameTitle && existingSongWithSameTitle.uuid !== uuid) {
                    showMessage(`A song with the title "${newTitle}" already exists.`, "error");
                    return;
                }
                songLibrary[songIndex].title = newTitle;
                songLibrary[songIndex].artist = newArtist;
                songLibrary[songIndex].groups = newGroups;
                await saveToFirestore('songLibrary', songLibrary);
                showMessage(`Song "${newTitle}" updated successfully!`, "success");
                closeEditModal();
                renderSongLibrary();
                updateAllSongDropdowns();
            } catch (error) {
                console.error("Error saving edited song:", error);
                showMessage("Failed to save song changes.", "error");
            }
        });

        async function deleteSong(uuid) {
            try {
                const songToDelete = getSongByUUID(uuid);
                if (!songToDelete) {
                    showMessage("Song not found for deletion.", "error");
                    return;
                }
                const confirmDelete = window.confirm(`Are you sure you want to delete "${songToDelete.title}"? This cannot be undone.`);
                if (!confirmDelete) return;
                songLibrary = songLibrary.filter(song => song.uuid !== uuid);
                await saveToFirestore('songLibrary', songLibrary);
                showMessage(`Song "${songToDelete.title}" deleted successfully!`, "success");
                closeEditModal();
                renderSongLibrary();
                updateAllSongDropdowns();
            } catch (error) {
                console.error("Error deleting song:", error);
                showMessage("Failed to delete song.", "error");
            }
        }

        cancelEditBtn.addEventListener('click', closeEditModal);
        deleteSongBtn.addEventListener('click', () => deleteSong(editSongUuidInput.value));

        saveSettingsBtn.addEventListener('click', async () => {
            try {
                const newSettings = [];
                for (let i = 0; i < NUM_SONG_PICKS; i++) {
                    const input = document.getElementById(`slotGroups${i + 1}`);
                    const groups = input && input.value ? input.value.split(',').map(g => g.trim()).filter(g => g !== '') : [];
                    newSettings.push(groups);
                }
                allowedGroupsForSlots = newSettings;
                await saveToFirestore('allowedGroupsForSlots', allowedGroupsForSlots);
                showMessage("Song slot settings saved successfully!", "success");
                renderSettingsInputs();
                updateAllSongDropdowns();
            } catch (error) {
                console.error("Error saving settings:", error);
                showMessage("Failed to save settings.", "error");
            }
        });

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM loaded, waiting for auth state");
        });
    </script>
</body>
</html>